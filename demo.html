<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html> -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - cascaded shadow maps</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- <link type="text/css" rel="stylesheet" href="main.css" /> -->
  </head>
  <body>
    <div id="container"></div>
    <div id="info">招商蛇口项目项目3D图演示</div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
      import { CSM } from 'three/addons/csm/CSM.js';
      import { CSMHelper } from 'three/addons/csm/CSMHelper.js';

      let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;

      // 创建一个射线投射器
      const raycaster = new THREE.Raycaster();

      // 创建一个鼠标向量
      const mouse = new THREE.Vector2();

      const params = {
        orthographic: false,
        fade: false,
        far: 1000,
        mode: 'practical',
        lightX: -1,
        lightY: -1,
        lightZ: -1,
        margin: 100,
        lightFar: 5000,
        lightNear: 1,
        autoUpdateHelper: true,
        updateHelper: function () {
          csmHelper.update();
        },
      };

      function updateOrthoCamera() {
        const size = controls.target.distanceTo(camera.position);
        const aspect = camera.aspect;

        orthoCamera.left = (size * aspect) / -2;
        orthoCamera.right = (size * aspect) / 2;

        orthoCamera.top = size / 2;
        orthoCamera.bottom = size / -2;
        orthoCamera.position.copy(camera.position);
        orthoCamera.rotation.copy(camera.rotation);
        orthoCamera.updateProjectionMatrix();
      }

      // #region 楼盘参数初始化
      const lpmc = {
        text: '',
      };
      const ksmj = {
        text: '',
      };
      const zhz = {
        text: '',
      };
      const gcjd = {
        text: '',
      };
      const qhl = {
        text: '',
      };
      const dsrq = {
        text: '',
      };
      const qzrq = {
        text: '',
      };
      const kprq = {
        text: '',
      };
      const jgrq = {
        text: '',
      };

      // #endregion

      let gui = new GUI();
      let guicolor = 'red';
      /**
       * 菜单
       * */
      function guiinit() {
        // 获取默认文件夹对象
        gui.$title.innerText = '楼盘信息';
        // 创建多个文本项
        const textItems = [];
        textItems.push(gui.add(lpmc, 'text').name('楼盘id'));
        textItems.push(gui.add(ksmj, 'text').name('楼盘信息'));
        textItems.push(gui.add(zhz, 'text').name('楼盘位置'));
        textItems.push(gui.add(gcjd, 'text').name('楼盘坐标'));
        textItems.push(gui.add(qhl, 'text').name('信息版本'));
        textItems.push(gui.add(dsrq, 'text').name('同步日期'));
        // 批量设置文本项的样式
        textItems.forEach((item) => {
          item.domElement.style.color = guicolor; // 设置为红色
        });
        gui.close();

        // // 获取文本字段的DOM元素
        // const textElement = textControl.domElement.getElementsByTagName('input')[0];

        // // 设置文本字段为只读
        // textElement.readOnly = true;
      }

      function init() {
        scene = new THREE.Scene();
        // scene.background = new THREE.Color('#454e61');
        scene.background = new THREE.Color('rgb(192, 192, 192)');
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
        orthoCamera = new THREE.OrthographicCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        controls = new OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI / 2;
        camera.position.set(160, 260, -250);
        controls.target = new THREE.Vector3(-200, 10, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const additionalDirectionalLight = new THREE.DirectionalLight(0x000020, 0.5);
        additionalDirectionalLight.position
          .set(params.lightX, params.lightY, params.lightZ)
          .normalize()
          .multiplyScalar(-200);
        scene.add(additionalDirectionalLight);

        csm = new CSM({
          maxFar: params.far,
          cascades: 4,
          mode: params.mode,
          parent: scene,
          shadowMapSize: 1024,
          lightDirection: new THREE.Vector3(
            params.lightX,
            params.lightY,
            params.lightZ
          ).normalize(),
          camera: camera,
        });

        csmHelper = new CSMHelper(csm);
        csmHelper.visible = false;
        scene.add(csmHelper);

        // #region 背景设置
        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('bg1.png', function (texture) {
          // 获取背景纹理图像的原始尺寸
          const textureWidth = texture.image.width;
          const textureHeight = texture.image.height;

          // 计算缩放因子
          const canvasWidth = window.innerWidth;
          const canvasHeight = window.innerHeight;
          const aspectRatio = canvasWidth / canvasHeight;
          const scale = Math.max(
            (canvasWidth / textureWidth) * 0.4,
            (canvasHeight / textureHeight) * 0.4
          );

          // 创建背景平面
          const planeGeometry = new THREE.PlaneGeometry(
            textureWidth * scale,
            textureHeight * scale
          );
          const planeMaterial = new THREE.MeshBasicMaterial({ map: texture });

          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(-250, 0, 0); // 将平面向下平移以居中显示
          plane.rotation.x = -Math.PI / 2;

          scene.add(plane);
        });
        // #endregion

        window.addEventListener('resize', function () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          updateOrthoCamera();
          csm.updateFrustums();

          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 点击事件绑定
        window.addEventListener('click', onMouseClick);
      }

      function getClickableObjects(scene) {
        const clickableObjects = [];

        scene.traverse((obj) => {
          if (obj instanceof THREE.Mesh && obj.castShadow) {
            clickableObjects.push(obj);
          }
        });

        return clickableObjects;
      }

      function onMouseClick(event) {
        // 获取点击的屏幕坐标
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        zhz.text = mouse.x;
        gcjd.text = mouse.y;
        gui = new GUI(); // 将新的 GUI 对象赋值给原来的 gui 变量
        guiinit();
        gui.open();
      }

      function animate() {
        requestAnimationFrame(animate);

        camera.updateMatrixWorld();
        csm.update();
        controls.update();

        if (params.orthographic) {
          updateOrthoCamera();
          csm.updateFrustums();

          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, orthoCamera);
        } else {
          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, camera);
        }
      }

      init();
      animate();
      guiinit();
    </script>
  </body>
</html>
