<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html> -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - cascaded shadow maps</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- <link type="text/css" rel="stylesheet" href="main.css" /> -->
  </head>
  <body>
    <div id="container"></div>
    <div id="info">招商蛇口项目项目3D图演示</div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
      import { CSM } from 'three/addons/csm/CSM.js';
      import { CSMHelper } from 'three/addons/csm/CSMHelper.js';

      let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;

      // 创建一个射线投射器
      const raycaster = new THREE.Raycaster();

      // 创建一个鼠标向量
      const mouse = new THREE.Vector2();

      const params = {
        orthographic: false,
        fade: false,
        far: 1000,
        mode: 'practical',
        lightX: -1,
        lightY: -1,
        lightZ: -1,
        margin: 100,
        lightFar: 5000,
        lightNear: 1,
        autoUpdateHelper: true,
        updateHelper: function () {
          csmHelper.update();
        },
      };

      function updateOrthoCamera() {
        const size = controls.target.distanceTo(camera.position);
        const aspect = camera.aspect;

        orthoCamera.left = (size * aspect) / -2;
        orthoCamera.right = (size * aspect) / 2;

        orthoCamera.top = size / 2;
        orthoCamera.bottom = size / -2;
        orthoCamera.position.copy(camera.position);
        orthoCamera.rotation.copy(camera.rotation);
        orthoCamera.updateProjectionMatrix();
      }

      // #region 楼盘参数初始化
      const lpmc = {
        text: '',
      };
      const ksmj = {
        text: '',
      };
      const zhz = {
        text: '',
      };
      const gcjd = {
        text: '',
      };
      const qhl = {
        text: '',
      };
      const dsrq = {
        text: '',
      };
      const qzrq = {
        text: '',
      };
      const kprq = {
        text: '',
      };
      const jgrq = {
        text: '',
      };

      let gui = new GUI();
      let guicolor = 'red';
      // #endregion

      /**
       * 菜单
       * */
      function guiinit() {
        // 获取默认文件夹对象
        gui.$title.innerText = '楼盘信息';
        // 创建多个文本项
        const textItems = [];
        textItems.push(gui.add(lpmc, 'text').name('楼盘名称'));
        textItems.push(gui.add(ksmj, 'text').name('可售面积'));
        textItems.push(gui.add(zhz, 'text').name('总货值'));
        textItems.push(gui.add(gcjd, 'text').name('工程进度'));
        textItems.push(gui.add(qhl, 'text').name('去化率'));
        textItems.push(gui.add(dsrq, 'text').name('达售日期'));
        textItems.push(gui.add(qzrq, 'text').name('取证日期'));
        textItems.push(gui.add(kprq, 'text').name('开盘日期'));
        textItems.push(gui.add(jgrq, 'text').name('竣工日期'));
        // 批量设置文本项的样式
        textItems.forEach((item) => {
          item.domElement.style.color = guicolor; // 设置为红色
        });
        gui.close();

        // // 获取文本字段的DOM元素
        // const textElement = textControl.domElement.getElementsByTagName('input')[0];

        // // 设置文本字段为只读
        // textElement.readOnly = true;
      }

      function init() {
        scene = new THREE.Scene();
        // scene.background = new THREE.Color('#454e61');
        scene.background = new THREE.Color('rgb(192, 192, 192)');
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
        orthoCamera = new THREE.OrthographicCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        controls = new OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI / 2;
        camera.position.set(160, 260, -250);
        controls.target = new THREE.Vector3(-200, 10, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const additionalDirectionalLight = new THREE.DirectionalLight(0x000020, 0.5);
        additionalDirectionalLight.position
          .set(params.lightX, params.lightY, params.lightZ)
          .normalize()
          .multiplyScalar(-200);
        scene.add(additionalDirectionalLight);

        csm = new CSM({
          maxFar: params.far,
          cascades: 4,
          mode: params.mode,
          parent: scene,
          shadowMapSize: 1024,
          lightDirection: new THREE.Vector3(
            params.lightX,
            params.lightY,
            params.lightZ
          ).normalize(),
          camera: camera,
        });

        csmHelper = new CSMHelper(csm);
        csmHelper.visible = false;
        scene.add(csmHelper);

        // #region 背景设置
        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('bg1.png', function (texture) {
          // 获取背景纹理图像的原始尺寸
          const textureWidth = texture.image.width;
          const textureHeight = texture.image.height;

          // 计算缩放因子
          const canvasWidth = window.innerWidth;
          const canvasHeight = window.innerHeight;
          const aspectRatio = canvasWidth / canvasHeight;
          const scale = Math.max(
            (canvasWidth / textureWidth) * 0.4,
            (canvasHeight / textureHeight) * 0.4
          );

          // 创建背景平面
          const planeGeometry = new THREE.PlaneGeometry(
            textureWidth * scale,
            textureHeight * scale
          );
          const planeMaterial = new THREE.MeshBasicMaterial({ map: texture });

          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(-250, 0, 0); // 将平面向下平移以居中显示
          plane.rotation.x = -Math.PI / 2;

          scene.add(plane);
        });
        // #endregion

        const material11 = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.7,
        });
        csm.setupMaterial(material11);

        const setFool = (
          color = '0x00ff00',
          box1x = 30,
          box1h = 9,
          box1y = 50,
          box2x = 30,
          box2h = 21,
          box2y = 50,
          boxp1x = -360,
          boxp1y = -60,
          boxp2x = boxp1x,
          boxp2y = boxp1y
        ) => {
          // #region 组合 楼栋3
          const material32 = new THREE.MeshPhongMaterial({
            color,
            transparent: true,
            opacity: 0.8,
          });
          csm.setupMaterial(material32);
          const geometry31 = new THREE.BoxGeometry(box1x, box1h, box1y);
          const geometry32 = new THREE.BoxGeometry(box2x, box2h, box2y);
          // 创建上半部分立方体
          const topCube3 = new THREE.Mesh(geometry31, material11);
          topCube3.castShadow = true;
          topCube3.receiveShadow = true;
          topCube3.userData.id = 3; // 设置自定义属性id
          scene.add(topCube3);

          // 创建下半部分立方体
          const bottomCube3 = new THREE.Mesh(geometry32, material32);
          bottomCube3.castShadow = true;
          bottomCube3.receiveShadow = true;
          bottomCube3.userData.id = 3;
          scene.add(bottomCube3);

          // 设置上半部分立方体的位置和缩放
          topCube3.position.set(boxp1x, box1h + box2h + box2h, boxp1y);
          topCube3.scale.set(1, 2, 1);
          // topCube.scale.y = Math.random() * 2 + 6;

          // 设置下半部分立方体的位置和缩放
          bottomCube3.position.set(boxp2x, box2h, boxp2y);
          bottomCube3.scale.set(1, 2, 1);
          // bottomCube.scale.y = Math.random() * 2 + 6;
          // #endregion
        };

        setFool('#ff2e63', 30, 21, 20, 30, 40, 20, -200, 100);

        setFool('#ff2e63', 30, 21, 20, 30, 40, 20, -360, 100);

        setFool('#ff2e63', 30, 21, 20, 30, 40, 20, -420, 120);

        setFool('#ff2e63', 80, 21, 20, 80, 41, 20, -120, 120);

        setFool(0x00ff00, 80, 21, 20, 80, 41, 20, -20, 160);

        setFool(0x00ff00, 30, 21, 20, 30, 21, 20, -20, -80);

        setFool(0x00ff00, 30, 21, 20, 30, 11, 20, -120, -90);

        setFool(0xffff54, 30, 21, 20, 30, 11, 20, -80, -70);

        setFool(0xffff54, 30, 21, 20, 30, 11, 20, -80, 30);

        setFool(0xffff54, 30, 21, 20, 60, 11, 60, 10, 30);

        setFool('#ff2e63', 30, 21, 20, 30, 9, 20, -360, 10);

        setFool('#ff2e63', 30, 21, 20, 30, 20, 20, -460, 20);

        setFool('#ff2e63', 30, 21, 20, 30, 10, 20, -420, 30);

        setFool(0xffff54, 30, 21, 20, 30, 9, 20, -280, 30);

        setFool(0x00ff00, 30, 21, 20, 30, 9, 20, -280, -60);

        setFool(0x00ff00, 30, 21, 20, 30, 40, 20, -260, 90);

        setFool(0x00ff00, 30, 21, 20, 30, 9, 20, -180, -10);

        setFool(0x00ff00, 30, 21, 20, 30, 9, 20, -220, -70);

        setFool('#ff2e63', 30, 21, 20, 30, 9, 20, -370, -80);
        // // #region 组合 楼栋1

        // const material12 = new THREE.MeshPhongMaterial({
        //   color: '#ff2e63',
        //   transparent: true,
        //   opacity: 0.7,
        // });
        // csm.setupMaterial(material12);
        // // 创建上半部分立方体
        // const geometry1 = new THREE.BoxGeometry(30, 21, 20);
        // const topCube = new THREE.Mesh(geometry1, material11);
        // topCube.castShadow = true;
        // topCube.receiveShadow = true;
        // topCube.userData.id = 1; // 设置自定义属性id
        // scene.add(topCube);

        // // 创建下半部分立方体
        // const geometry2 = new THREE.BoxGeometry(30, 9, 20);
        // const bottomCube = new THREE.Mesh(geometry2, material12);
        // bottomCube.castShadow = true;
        // bottomCube.receiveShadow = true;
        // bottomCube.userData.id = 1;
        // scene.add(bottomCube);

        // // 设置上半部分立方体的位置和缩放
        // topCube.position.set(-200, 39, 100);
        // topCube.scale.set(1, 2, 1);
        // // topCube.scale.y = Math.random() * 2 + 6;

        // // 设置下半部分立方体的位置和缩放
        // bottomCube.position.set(-200, 9, 100);
        // bottomCube.scale.set(1, 2, 1);
        // // bottomCube.scale.y = Math.random() * 2 + 6;
        // // #endregion

        // // #region 组合 楼栋2

        // const material22 = new THREE.MeshPhongMaterial({
        //   color: 0xffff54,
        //   transparent: true,
        //   opacity: 0.7,
        // });
        // csm.setupMaterial(material22);
        // const geometry21 = new THREE.BoxGeometry(30, 15, 20);
        // const geometry22 = new THREE.BoxGeometry(30, 15, 20);
        // // 创建上半部分立方体
        // const topCube2 = new THREE.Mesh(geometry21, material11);
        // topCube2.castShadow = true;
        // topCube2.receiveShadow = true;
        // topCube2.userData.id = 2; // 设置自定义属性id
        // scene.add(topCube2);

        // // 创建下半部分立方体
        // const bottomCube2 = new THREE.Mesh(geometry22, material22);
        // bottomCube2.castShadow = true;
        // bottomCube2.receiveShadow = true;
        // bottomCube2.userData.id = 2;
        // scene.add(bottomCube2);

        // // 设置上半部分立方体的位置和缩放
        // topCube2.position.set(-360, 45, 100);
        // topCube2.scale.set(1, 2, 1);
        // // topCube.scale.y = Math.random() * 2 + 6;

        // // 设置下半部分立方体的位置和缩放
        // bottomCube2.position.set(-360, 15, 100);
        // bottomCube2.scale.set(1, 2, 1);
        // // bottomCube.scale.y = Math.random() * 2 + 6;
        // // #endregion

        // // #region 组合 楼栋3
        // const material32 = new THREE.MeshPhongMaterial({
        //   color: 0x00ff00,
        //   transparent: true,
        //   opacity: 0.7,
        // });
        // csm.setupMaterial(material32);
        // const geometry31 = new THREE.BoxGeometry(30, 9, 50);
        // const geometry32 = new THREE.BoxGeometry(30, 21, 50);
        // // 创建上半部分立方体
        // const topCube3 = new THREE.Mesh(geometry31, material11);
        // topCube3.castShadow = true;
        // topCube3.receiveShadow = true;
        // topCube3.userData.id = 3; // 设置自定义属性id
        // scene.add(topCube3);

        // // 创建下半部分立方体
        // const bottomCube3 = new THREE.Mesh(geometry32, material32);
        // bottomCube3.castShadow = true;
        // bottomCube3.receiveShadow = true;
        // bottomCube3.userData.id = 3;
        // scene.add(bottomCube3);

        // // 设置上半部分立方体的位置和缩放
        // topCube3.position.set(-360, 51, -65);
        // topCube3.scale.set(1, 2, 1);
        // // topCube.scale.y = Math.random() * 2 + 6;

        // // 设置下半部分立方体的位置和缩放
        // bottomCube3.position.set(-360, 21, -65);
        // bottomCube3.scale.set(1, 2, 1);
        // // bottomCube.scale.y = Math.random() * 2 + 6;
        // // #endregion

        // // #region 组合 楼栋4
        // // 创建上半部分立方体
        // const material42 = new THREE.MeshPhongMaterial({
        //   color: 0x888888,
        //   transparent: true,
        //   opacity: 0.7,
        // });
        // csm.setupMaterial(material32);
        // const geometry41 = new THREE.BoxGeometry(30, 15, 50);
        // const geometry42 = new THREE.BoxGeometry(30, 10, 50);
        // const topCube4 = new THREE.Mesh(geometry41, material11);
        // topCube4.castShadow = true;
        // topCube4.receiveShadow = true;
        // topCube4.userData.id = 4; // 设置自定义属性id
        // scene.add(topCube4);

        // // 创建下半部分立方体
        // const bottomCube4 = new THREE.Mesh(geometry42, material42);
        // bottomCube4.castShadow = true;
        // bottomCube4.receiveShadow = true;
        // bottomCube4.userData.id = 4;
        // scene.add(bottomCube4);

        // // 设置上半部分立方体的位置和缩放
        // topCube4.position.set(-200, 35, -65);
        // topCube4.scale.set(1, 2, 1);
        // // topCube.scale.y = Math.random() * 2 + 6;

        // // 设置下半部分立方体的位置和缩放
        // bottomCube4.position.set(-200, 10, -65);
        // bottomCube4.scale.set(1, 2, 1);
        // // bottomCube.scale.y = Math.random() * 2 + 6;
        // // #endregion

        // #endregion

        window.addEventListener('resize', function () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          updateOrthoCamera();
          csm.updateFrustums();

          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 点击事件绑定
        window.addEventListener('click', onMouseClick);
      }

      function getClickableObjects(scene) {
        const clickableObjects = [];

        scene.traverse((obj) => {
          if (obj instanceof THREE.Mesh && obj.castShadow) {
            clickableObjects.push(obj);
          }
        });

        return clickableObjects;
      }

      function onMouseClick(event) {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const clickableObjects = getClickableObjects(scene);
        const intersects = raycaster.intersectObjects(clickableObjects);

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject instanceof THREE.Mesh) {
            const id = clickedObject.userData.id;
            id && setGui(id);
          }
        }
      }

      function setGui(id) {
        if (id === 1) {
          lpmc.text = '2期-1批次-1A栋 住宅-超高层';
          ksmj.text = '1280.00\u33A1';
          zhz.text = '38400.00万元';
          gcjd.text = '18/36 50%';
          qhl.text = '22.22%';
          dsrq.text = '2023-07-10';
          qzrq.text = '2023-07-14';
          kprq.text = '2023-08-10';
          jgrq.text = '2023-08-20';
          guicolor = 'red';
        } else if (id === 2) {
          lpmc.text = '2期-2批次-2A栋 住宅-超高层';
          ksmj.text = '1280.00\u33A1';
          zhz.text = '39400.00万元';
          gcjd.text = '21/36 60%';
          qhl.text = '56.22%';
          dsrq.text = '2023-07-10';
          qzrq.text = '2023-07-14';
          kprq.text = '2023-08-10';
          jgrq.text = '2023-08-20';
          guicolor = 'yellow';
        } else if (id === 3) {
          lpmc.text = '1期-2批次-3A栋 住宅-超高层';
          ksmj.text = '1280.00\u33A1';
          zhz.text = '39400.00万元';
          gcjd.text = '21/36 60%';
          qhl.text = '80.32%';
          dsrq.text = '2023-05-10';
          qzrq.text = '2023-05-14';
          kprq.text = '2023-06-10';
          jgrq.text = '2023-06-20';
          guicolor = 'green';
        } else {
          lpmc.text = '3期-1批次-4A栋 住宅-超高层';
          ksmj.text = '1280.00\u33A1';
          zhz.text = '39400.00万元';
          gcjd.text = '40/42 90%';
          qhl.text = '未开售';
          dsrq.text = '2023-09-10';
          qzrq.text = '2023-09-14';
          kprq.text = '2023-09-10';
          jgrq.text = '2023-09-20';
          guicolor = 'gray';
        }
        // gui.destroy(); // 销毁旧的 GUI 对象
        gui = new GUI(); // 将新的 GUI 对象赋值给原来的 gui 变量
        guiinit();
        gui.open();
      }

      function animate() {
        requestAnimationFrame(animate);

        camera.updateMatrixWorld();
        csm.update();
        controls.update();

        if (params.orthographic) {
          updateOrthoCamera();
          csm.updateFrustums();

          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, orthoCamera);
        } else {
          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, camera);
        }
      }

      init();
      animate();
      guiinit();
    </script>
  </body>
</html>
