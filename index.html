<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html> -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - cascaded shadow maps</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <!-- <link type="text/css" rel="stylesheet" href="main.css" /> -->
  </head>
  <body>
    <div id="container"></div>
    <div id="info">招商蛇口项目项目3D图演示</div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
      import { CSM } from 'three/addons/csm/CSM.js';
      import { CSMHelper } from 'three/addons/csm/CSMHelper.js';

      let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;

      // 创建一个射线投射器
      const raycaster = new THREE.Raycaster();

      // 创建一个鼠标向量
      const mouse = new THREE.Vector2();

      const params = {
        orthographic: false,
        fade: false,
        far: 1000,
        mode: 'practical',
        lightX: -1,
        lightY: -1,
        lightZ: -1,
        margin: 100,
        lightFar: 5000,
        lightNear: 1,
        autoUpdateHelper: true,
        updateHelper: function () {
          csmHelper.update();
        },
      };

      init();
      animate();

      function updateOrthoCamera() {
        const size = controls.target.distanceTo(camera.position);
        const aspect = camera.aspect;

        orthoCamera.left = (size * aspect) / -2;
        orthoCamera.right = (size * aspect) / 2;

        orthoCamera.top = size / 2;
        orthoCamera.bottom = size / -2;
        orthoCamera.position.copy(camera.position);
        orthoCamera.rotation.copy(camera.rotation);
        orthoCamera.updateProjectionMatrix();
      }

      function init() {
        scene = new THREE.Scene();
        // scene.background = new THREE.Color('#454e61');
        scene.background = new THREE.Color('#0xffffff');
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
        orthoCamera = new THREE.OrthographicCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        controls = new OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI / 2;
        camera.position.set(160, 260, -250);
        controls.target = new THREE.Vector3(-200, 10, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const additionalDirectionalLight = new THREE.DirectionalLight(0x000020, 0.5);
        additionalDirectionalLight.position
          .set(params.lightX, params.lightY, params.lightZ)
          .normalize()
          .multiplyScalar(-200);
        scene.add(additionalDirectionalLight);

        csm = new CSM({
          maxFar: params.far,
          cascades: 4,
          mode: params.mode,
          parent: scene,
          shadowMapSize: 1024,
          lightDirection: new THREE.Vector3(
            params.lightX,
            params.lightY,
            params.lightZ
          ).normalize(),
          camera: camera,
        });

        csmHelper = new CSMHelper(csm);
        csmHelper.visible = false;
        scene.add(csmHelper);

        // #region 背景设置
        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('bg1.png', function (texture) {
          // 获取背景纹理图像的原始尺寸
          const textureWidth = texture.image.width;
          const textureHeight = texture.image.height;

          // 计算缩放因子
          const canvasWidth = window.innerWidth;
          const canvasHeight = window.innerHeight;
          const aspectRatio = canvasWidth / canvasHeight;
          const scale = Math.max(
            (canvasWidth / textureWidth) * 0.4,
            (canvasHeight / textureHeight) * 0.4
          );

          // 创建背景平面
          const planeGeometry = new THREE.PlaneGeometry(
            textureWidth * scale,
            textureHeight * scale
          );
          const planeMaterial = new THREE.MeshBasicMaterial({ map: texture });

          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(-250, 0, 0); // 将平面向下平移以居中显示
          plane.rotation.x = -Math.PI / 2;

          scene.add(plane);
        });
        // #endregion

        const material1 = new THREE.MeshPhongMaterial({ color: '#08d9d6' });
        csm.setupMaterial(material1);

        const material2 = new THREE.MeshPhongMaterial({ color: '#ff2e63' });
        csm.setupMaterial(material2);

        const geometry = new THREE.BoxGeometry(100, 50, 50);

        // #region 建筑物设置

        // #region 组合 楼栋1
        // 创建上半部分立方体
        const topCube = new THREE.Mesh(geometry, material1);
        topCube.castShadow = true;
        topCube.receiveShadow = true;
        topCube.userData.id = 1; // 设置自定义属性id
        scene.add(topCube);

        // 创建下半部分立方体
        const bottomCube = new THREE.Mesh(geometry, material2);
        bottomCube.castShadow = true;
        bottomCube.receiveShadow = true;
        bottomCube.userData.id = 1;
        scene.add(bottomCube);

        // 设置上半部分立方体的位置和缩放
        topCube.position.set(-200, 150, 100);
        topCube.scale.set(1, 2, 1);
        // topCube.scale.y = Math.random() * 2 + 6;

        // 设置下半部分立方体的位置和缩放
        bottomCube.position.set(-200, 50, 100);
        bottomCube.scale.set(1, 2, 1);
        // bottomCube.scale.y = Math.random() * 2 + 6;
        // #endregion

        // #region 组合 楼栋2
        // 创建上半部分立方体
        const topCube2 = new THREE.Mesh(geometry, material1);
        topCube2.castShadow = true;
        topCube2.receiveShadow = true;
        topCube2.userData.id = 1; // 设置自定义属性id
        scene.add(topCube2);

        // 创建下半部分立方体
        const bottomCube2 = new THREE.Mesh(geometry, material2);
        bottomCube2.castShadow = true;
        bottomCube2.receiveShadow = true;
        bottomCube2.userData.id = 1;
        scene.add(bottomCube2);

        // 设置上半部分立方体的位置和缩放
        topCube2.position.set(-360, 150, 100);
        topCube2.scale.set(1, 2, 1);
        // topCube.scale.y = Math.random() * 2 + 6;

        // 设置下半部分立方体的位置和缩放
        bottomCube2.position.set(-360, 50, 100);
        bottomCube2.scale.set(1, 2, 1);
        // bottomCube.scale.y = Math.random() * 2 + 6;
        // #endregion

        // #region 组合 楼栋3
        // 创建上半部分立方体
        const topCube3 = new THREE.Mesh(geometry, material1);
        topCube3.castShadow = true;
        topCube3.receiveShadow = true;
        topCube3.userData.id = 1; // 设置自定义属性id
        scene.add(topCube3);

        // 创建下半部分立方体
        const bottomCube3 = new THREE.Mesh(geometry, material2);
        bottomCube3.castShadow = true;
        bottomCube3.receiveShadow = true;
        bottomCube3.userData.id = 1;
        scene.add(bottomCube3);

        // 设置上半部分立方体的位置和缩放
        topCube3.position.set(-360, 150, -65);
        topCube3.scale.set(1, 2, 1);
        // topCube.scale.y = Math.random() * 2 + 6;

        // 设置下半部分立方体的位置和缩放
        bottomCube3.position.set(-360, 50, -65);
        bottomCube3.scale.set(1, 2, 1);
        // bottomCube.scale.y = Math.random() * 2 + 6;
        // #endregion

        // #region 组合 楼栋4
        // 创建上半部分立方体
        const topCube4 = new THREE.Mesh(geometry, material1);
        topCube4.castShadow = true;
        topCube4.receiveShadow = true;
        topCube4.userData.id = 1; // 设置自定义属性id
        scene.add(topCube4);

        // 创建下半部分立方体
        const bottomCube4 = new THREE.Mesh(geometry, material2);
        bottomCube4.castShadow = true;
        bottomCube4.receiveShadow = true;
        bottomCube4.userData.id = 1;
        scene.add(bottomCube4);

        // 设置上半部分立方体的位置和缩放
        topCube4.position.set(-200, 150, -65);
        topCube4.scale.set(1, 2, 1);
        // topCube.scale.y = Math.random() * 2 + 6;

        // 设置下半部分立方体的位置和缩放
        bottomCube4.position.set(-200, 50, -65);
        bottomCube4.scale.set(1, 2, 1);
        // bottomCube.scale.y = Math.random() * 2 + 6;
        // #endregion

        // #endregion

        // for (let i = 0; i < 20; i++) {
        //   // #region 组合
        //   // 创建上半部分立方体
        //   const topCube = new THREE.Mesh(geometry, material1);
        //   topCube.castShadow = true;
        //   topCube.receiveShadow = true;
        //   topCube.userData.id = i + 1; // 设置自定义属性id
        //   scene.add(topCube);

        //   // 创建下半部分立方体
        //   const bottomCube = new THREE.Mesh(geometry, material2);
        //   bottomCube.castShadow = true;
        //   bottomCube.receiveShadow = true;
        //   bottomCube.userData.id = i + 1;
        //   scene.add(bottomCube);

        //   // 设置上半部分立方体的位置和缩放
        //   topCube.position.set(-i * 25, 30, 30);
        //   topCube.scale.set(1, 2, 1);
        //   // topCube.scale.y = Math.random() * 2 + 6;

        //   // 设置下半部分立方体的位置和缩放
        //   bottomCube.position.set(-i * 25, 10, 30);
        //   bottomCube.scale.set(1, 2, 1);
        //   // bottomCube.scale.y = Math.random() * 2 + 6;
        //   // #endregion
        // }

        window.addEventListener('resize', function () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          updateOrthoCamera();
          csm.updateFrustums();

          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 点击事件绑定
        window.addEventListener('click', onMouseClick);
      }

      function getClickableObjects(scene) {
        const clickableObjects = [];

        scene.traverse((obj) => {
          if (obj instanceof THREE.Mesh && obj.castShadow) {
            clickableObjects.push(obj);
          }
        });

        return clickableObjects;
      }

      function onMouseClick(event) {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const clickableObjects = getClickableObjects(scene);
        const intersects = raycaster.intersectObjects(clickableObjects);

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject instanceof THREE.Mesh) {
            const id = clickedObject.userData.id;
            id && window.alert('我是楼座' + id);
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        camera.updateMatrixWorld();
        csm.update();
        controls.update();

        if (params.orthographic) {
          updateOrthoCamera();
          csm.updateFrustums();

          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, orthoCamera);
        } else {
          if (params.autoUpdateHelper) {
            csmHelper.update();
          }

          renderer.render(scene, camera);
        }
      }
    </script>
  </body>
</html>
